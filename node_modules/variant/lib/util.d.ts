import { WithProperty, VariantModule } from './variant';
/**
 * Useful in generating friendly types. Intersections are rendered as the type of the intersection, not as A & B.
 */
export declare type Identity<T> = {} & {
    [P in keyof T]: T[P];
};
export declare const identityFunc: <T>(x?: T | undefined) => T extends unknown ? {} : T;
export declare type Func = (...args: any[]) => any;
export interface FuncObject {
    [key: string]: Func;
}
/**
 * Extract the data type from a function, whether it returns the
 * object directly or does so with a promise.
 */
export declare type GetDataType<T extends VariantModule<K>, K extends string = 'type'> = {
    [P in keyof T]: ReturnType<T[P]> extends PromiseLike<infer R> ? R extends WithProperty<K, string> ? R : never : ReturnType<T[P]>;
};
/**
 * Given a union of types all of which meet the contract {[K]: string}
 * extract the type that is specifically {[K]: TType}
 */
export declare type ExtractOfUnion<T, TType extends string, K extends string = 'type'> = T extends WithProperty<K, TType> ? T : never;
/**
 * Utility function to create a K:V from a list of strings
 *
 * Taken from: https://basarat.gitbook.io/typescript/type-system/literal-types#string-based-enums
 * */
export declare function strEnum<T extends string>(o: Array<T>): {
    [K in T]: K;
};
/**
 * Determine whether or not a variable is a promise.
 * @param x
 */
export declare function isPromise<T>(x: T | PromiseLike<T>): x is PromiseLike<T>;
//# sourceMappingURL=util.d.ts.map