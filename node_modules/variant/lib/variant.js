"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
/**
 * Use this function to generate a version of the `variant` factory function using
 * some arbitrary key. The default `variant` is just `variantFactory('type')`.
 * @param key The name of the property to use e.g. 'type', 'kind', 'version'
 */
function variantFactory(key) {
    function variantFunc(tag, func) {
        let maker = (...args) => {
            const returned = (func !== null && func !== void 0 ? func : util_1.identityFunc)(...args);
            if (util_1.isPromise(returned)) {
                return returned.then(result => (Object.assign({ [key]: tag }, result)));
            }
            else {
                return Object.assign({ [key]: tag }, returned);
            }
        };
        const outputs = {
            key,
            type: tag,
        };
        return Object.assign(maker, outputs, { toString: function () { return this.type; } });
    }
    // the `variant()` function advertises the key it will use
    const outputKey = { outputKey: key };
    return Object.assign(variantFunc, outputKey);
}
exports.variantFactory = variantFactory;
/**
 * Create a new variant of a given type.
 *
 *     const dog = variant('dog');
 *     const myDog = dog(); // {type: 'dog'}
 *
 *     const dog = variant('dog', payload<string>());
 *     const myDog = dog('Bandit'); // {type: 'dog', payload: 'Bandit'}
 *
 *     const dog = variant('dog', fields<{
 *         name: string;
 *         favoriteTreat?: string;
 *     });
 *     const myDog = dog({name: 'Bandit', favoriteTreat: 'carrots'}); // {type: 'dog}
 *
 *     const dog = variant('dog', (name: string, favoriteTreat = 'kibble') => ({name, favoriteTreat}));
 *     const myDog = dog('Bandit'); // {type: 'dog', name: 'Bandit', favoriteTreat: 'kibble'}
 */
exports.variant = variantFactory('type');
/**
 * Create
 */
exports.default = exports.variant;
/**
 * Basically works like strEnum to generate an object where the property keys are the variant type strings.
 * @param variants
 */
function variantList(variants) {
    return variants.reduce((o, v) => (Object.assign(Object.assign({}, o), { [v.type]: v })), Object.create(null));
}
exports.variantList = variantList;
/**
 * Give an array of output types for a given variant collection.
 * Useful for checking whether or not a message belongs in your
 * variant set at runtime.
 * @param variantObject
 */
function outputTypes(variantObject) {
    return Object.keys(variantObject).map(key => variantObject[key].type);
}
exports.outputTypes = outputTypes;
/**
 * Checks if an object is in a given variant module. You can give it the object
 * or any destructured subset or a variantList([...]) with specific items. Neat, huh?
 *
 * TODO: This doesn't yet work for variants that use type keys besides 'type'.
 * @param object
 * @param variant
 */
function isOfVariant(object, variant, typeKey) {
    return object != undefined && outputTypes(variant).some(type => type === object[typeKey !== null && typeKey !== void 0 ? typeKey : 'type']);
}
exports.isOfVariant = isOfVariant;
/**
 * Unused at the moment. Intended to develop the idea of an "ordered" variant.
 * @param variants
 */
function progression(variants) {
    return variants.reduce((o, v) => (Object.assign(Object.assign({}, o), { [v.type]: v })), Object.create(null));
}
/**
 * Match a variant against it's possible options and do some processing
 * based on the type of variant received.
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
function match(obj, handler, typeKey) {
    var _a;
    const typeString = obj[typeKey !== null && typeKey !== void 0 ? typeKey : 'type'];
    return (_a = handler[typeString]) === null || _a === void 0 ? void 0 : _a.call(handler, obj);
}
exports.match = match;
/**
 * Match a variant against it's some of its possible options and do some
 * processing based on the type of variant received. Finally, take the remaining
 * possibilities and handle them in a function.
 *
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
function matchElse(obj, handler, _else, typeKey) {
    var _a, _b;
    const typeString = obj[typeKey !== null && typeKey !== void 0 ? typeKey : 'type'];
    return (_b = (_a = handler[typeString]) === null || _a === void 0 ? void 0 : _a.call(handler, obj)) !== null && _b !== void 0 ? _b : _else(obj);
}
exports.matchElse = matchElse;
/**
 * Match a variant against some of its possible options and do some
 * processing based on the type of variant received. May return undefined
 * if the variant is not accounted for by the handler.
 * @param obj
 * @param handler
 * @param typeKey override the property to inspect. By default, 'type'.
 */
function partialMatch(obj, handler, typeKey) {
    return match(obj, handler, typeKey);
}
exports.partialMatch = partialMatch;
;
/**
 * Match a literal against some of its possible options and do some processing based
 * on the type of literal received. Works well with strEnum
 * @param literal
 * @param handler
 */
function matchLiteral(literal, handler) {
    var _a;
    return (_a = handler[literal]) === null || _a === void 0 ? void 0 : _a.call(handler, literal);
}
exports.matchLiteral = matchLiteral;
/**
 * Map a variant to some value based on the type of variant provided.
 * @param obj
 * @param handler
 * @param typeKey
 */
function lookup(obj, handler, typeKey) {
    const typeString = obj[typeKey !== null && typeKey !== void 0 ? typeKey : 'type'];
    return handler[typeString];
}
exports.lookup = lookup;
/**
 * Map a variant to some value or undefined based on the type of variant
 * provided. If he handler does not account for your use case, undefined
 * will be returned. The type of undefined is the union of the various
 * values in the object.
 * @param obj
 * @param handler
 * @param typeKey
 */
function partialLookup(obj, handler, typeKey) {
    // Takes advantage of the fact that handler with missing keys will return undefined.
    return lookup(obj, handler, typeKey);
}
exports.partialLookup = partialLookup;
function cast(obj, _type, _typeKey) {
    return obj;
}
exports.cast = cast;
function narrow(obj, type, typeKey) {
    const typeString = obj[typeKey !== null && typeKey !== void 0 ? typeKey : 'type'];
    return typeString === type ? obj : undefined;
}
exports.narrow = narrow;
/**
 * Expand the functionality of a variant as a whole by tacking on properties
 * generated by a thunk.
 * @param variantDef
 * @param f
 */
function augment(variantDef, f) {
    return Object.keys(variantDef).reduce((acc, key) => {
        const augmentedFuncWrapper = (...args) => (Object.assign({}, f(), variantDef[key](...args)));
        return Object.assign(Object.assign({}, acc), { [key]: Object.assign(augmentedFuncWrapper, { key: variantDef[key].key, type: variantDef[key].type }) });
    }, {});
}
exports.augment = augment;
function keynum(variantDef) {
    return util_1.strEnum(outputTypes(variantDef));
}
exports.keynum = keynum;
function flags(flags) {
    return flags.reduce((o, v) => (Object.assign(Object.assign({}, o), { [v.type]: v })), Object.create(null));
}
exports.flags = flags;
//# sourceMappingURL=variant.js.map