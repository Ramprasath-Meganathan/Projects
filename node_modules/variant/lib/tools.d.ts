/**
 * Enforce exhaustion of a union type by using this in the default case.
 * @param x
 * @param options
 */
export declare function exhaust(x: never, options?: {
    key: string;
    throw: boolean;
}): void;
declare type MarkOptional<T, O> = {
    [P in keyof T]: P extends keyof O ? (T[P] | undefined) : T[P];
};
/**
 * Handles boilerplate with the most common function definiton.
 * Also provides a clean way of describing things in a record-like
 * way.
 *
 * const ItemOne = variant('ITEM_ONE', fields<{
 *     id: number;
 *     name: string;
 * }>());
 *
 * You can also use .set() to assign some elements of an interface. For example:
 *
 * interface Audited<T> extends T {
 *     createdDate: number; // millis
 * }
 *
 * @param defaults set some default values for the object. Note this does not remove
 */
export declare function fields<T>(defaults?: Partial<T>): ((input: T) => T) & {
    set<D extends Partial<T>>(this: (x: T) => T, data: D): (input: { [P in keyof Pick<T, Exclude<keyof T, keyof D>>]: Pick<T, Exclude<keyof T, keyof D>>[P]; }) => { [P_1 in keyof (T & D)]: (T & D)[P_1]; };
    default<D_1>(this: (x: T) => T, data: D_1): (input: MarkOptional<T, D_1>) => T;
};
/**
 * FSA compliance.
 */
export declare function payload<T>(): (payload: T) => {
    payload: T;
};
export declare function property<K extends string = 'payload'>(key: K): <T>() => (payload: T) => K extends keyof infer KLiteral ? import("./variant").TypeExt<keyof KLiteral & string, T> : never;
export declare function data<T>(x: T): (override?: T | undefined) => T;
export {};
//# sourceMappingURL=tools.d.ts.map