import { Func } from "./util";
declare const name: unique symbol;
/**
 * Grants nominal typing in a structural space by describing a
 * (false) unique symbolic property.
 */
export declare type Nominal<T, Name> = T & {
    [name]: Name;
};
declare type AnonymousObject<T> = {
    [P in keyof T]: Anonymous<T[P]>;
};
declare type AnonymousTuple<T extends ReadonlyArray<any>> = {
    [P in keyof T]: T[P] extends Nominal<infer TValue, any> ? Anonymous<TValue> : T[P];
};
declare type AnonymousFunction<T> = T extends (...args: infer TArgs) => infer TR ? (...anonArgs: AnonymousTuple<TArgs>) => Anonymous<TR> : T;
declare type primitive = number | string | symbol | boolean;
/**
 * Anonymize a nominal type. Take an object that requires it's specific ids
 * and return one that doesn't. Great for taking in inputs. Most action creators
 * could go from Anonymous<T> => T
 */
export declare type Anonymous<T> = T extends Nominal<infer TValue, any> ? (TValue extends ReadonlyArray<any> ? AnonymousTuple<TValue> : TValue extends Func ? AnonymousFunction<TValue> : TValue extends primitive ? TValue : TValue extends object ? AnonymousObject<TValue> : T) : T extends ReadonlyArray<any> ? AnonymousTuple<T> : T extends (...args: any[]) => any ? AnonymousFunction<T> : T extends primitive ? T : T extends object ? AnonymousObject<T> : never;
export {};
//# sourceMappingURL=nominal.d.ts.map