import { Identity, Func, GetDataType, ExtractOfUnion } from './util';
export declare type TypeExt<K extends string, T> = K extends keyof infer LitK ? {
    [P in keyof LitK]: T;
} : never;
export declare type WithProperty<K extends string, T> = TypeExt<K, T>;
/**
 * The type marking metadata. It's useful to know the type of the items the function will generate.
 *
 * It doesn't *really* matter if it's creator.outputType vs. creator.type, but
 * the latter has the advantage of being tolerable to the group of people who will
 * prefer to use [Animal.dog.type]: rather than dog: .
 */
export declare type Outputs<K, T> = {
    key: K;
    /**
     * The type of object created by this function.
     */
    type: T;
};
/**
 * More specific toString();
 */
export declare type Stringable<ReturnType extends string> = {
    toString(): ReturnType;
};
/**
 * The constructor for one tag of a variant type.
 */
export declare type VariantCreator<T extends string, F extends (...args: any[]) => {}, K extends string = 'type'> = Stringable<T> & ((...args: Parameters<F>) => PatchObjectOrPromise<ReturnType<F>, WithProperty<K, T>>) & Outputs<K, T>;
export declare type PatchObjectOrPromise<T extends {} | PromiseLike<{}>, U extends {}> = T extends PromiseLike<infer R> ? PromiseLike<Identity<U & R>> : Identity<U & T>;
/**
 * The overall module of variants. This is equivalent to a polymorphic variant.
 */
export declare type VariantModule<K extends string = 'type'> = {
    [name: string]: VariantCreator<string, (...args: any[]) => any, K>;
};
/**
 * Use this function to generate a version of the `variant` factory function using
 * some arbitrary key. The default `variant` is just `variantFactory('type')`.
 * @param key The name of the property to use e.g. 'type', 'kind', 'version'
 */
export declare function variantFactory<K extends string>(key: K): {
    <T extends string>(tag: T): VariantCreator<T, () => {}, K>;
    <T_1 extends string, F extends Func>(tag: T_1, func: F): VariantCreator<T_1, F, K>;
} & {
    outputKey: K;
};
/**
 * Create a new variant of a given type.
 *
 *     const dog = variant('dog');
 *     const myDog = dog(); // {type: 'dog'}
 *
 *     const dog = variant('dog', payload<string>());
 *     const myDog = dog('Bandit'); // {type: 'dog', payload: 'Bandit'}
 *
 *     const dog = variant('dog', fields<{
 *         name: string;
 *         favoriteTreat?: string;
 *     });
 *     const myDog = dog({name: 'Bandit', favoriteTreat: 'carrots'}); // {type: 'dog}
 *
 *     const dog = variant('dog', (name: string, favoriteTreat = 'kibble') => ({name, favoriteTreat}));
 *     const myDog = dog('Bandit'); // {type: 'dog', name: 'Bandit', favoriteTreat: 'kibble'}
 */
export declare const variant: {
    <T extends string>(tag: T): VariantCreator<T, () => {}, "type">;
    <T_1 extends string, F extends Func>(tag: T_1, func: F): VariantCreator<T_1, F, "type">;
} & {
    outputKey: "type";
};
/**
 * Create
 */
export default variant;
export declare type Creators<T extends VariantModule<PropName>, PropName extends string = 'type'> = {
    [P in keyof T]: T[P] extends VariantCreator<string, Func, PropName> ? T[P] : never;
};
/**
 * DEPRECATED. Use VariantOf
 */
export declare type VariantsOf<T extends VariantModule<PropName>, PropName extends string = 'type'> = GetDataType<Creators<T, PropName>, PropName>;
/**
 * DEPRECATED. Use VariantOf
 */
export declare type OneOf<T> = T[keyof T];
declare type FilterVariants<T, Type extends string, K extends string = any> = T extends VariantCreator<Type, Func, K> ? T : never;
/**
 * Basically works like strEnum to generate an object where the property keys are the variant type strings.
 * @param variants
 */
export declare function variantList<T extends VariantCreator<any, Func, any>>(variants: Array<T>): {
    [P in T['type']]: FilterVariants<T, P>;
};
/**
 * Give an array of output types for a given variant collection.
 * Useful for checking whether or not a message belongs in your
 * variant set at runtime.
 * @param variantObject
 */
export declare function outputTypes<T extends {
    [name: string]: Outputs<string, string>;
}>(variantObject: T): string[];
/**
 * Checks if an object is in a given variant module. You can give it the object
 * or any destructured subset or a variantList([...]) with specific items. Neat, huh?
 *
 * TODO: This doesn't yet work for variants that use type keys besides 'type'.
 * @param object
 * @param variant
 */
export declare function isOfVariant<T extends VariantModule<K>, K extends string = 'type'>(object: {} | null | undefined, variant: T, typeKey?: K): object is SumType<T, K>;
/**
 * Built to describe an object with the same keys as a variant but instead of constructors
 * for those objects provides functions that handle objects of that type.
 */
export declare type Handler<T> = {
    [P in keyof T]: (variant: T[P]) => any;
};
/**
 * Same as handler but needs to handle literals instead of variants. Used by matchLiteral.
 */
export declare type UnionHandler<T extends string> = {
    [P in T]: (variant: P) => any;
};
/**
 * From a given union type, extract the the variant object's type.
 */
export declare type VariantsOfUnion<T extends WithProperty<K, string>, K extends string = 'type'> = {
    [P in T[K]]: ExtractOfUnion<T, P, K>;
};
declare type Defined<T> = T extends undefined ? never : T;
/**
 * Match a variant against it's possible options and do some processing
 * based on the type of variant received.
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
export declare function match<T extends WithProperty<K, string>, H extends Handler<VariantsOfUnion<T, K>>, K extends string = 'type'>(obj: T, handler: H, typeKey?: K): ReturnType<H[T[K]]>;
/**
 * Match a variant against it's some of its possible options and do some
 * processing based on the type of variant received. Finally, take the remaining
 * possibilities and handle them in a function.
 *
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
export declare function matchElse<T extends WithProperty<K, string>, H extends Partial<Handler<VariantsOfUnion<T, K>>>, E extends (rest: Exclude<T, TypeExt<K, keyof H>>) => any, K extends string = 'type'>(obj: T, handler: Partial<H>, _else: E, typeKey?: K): ReturnType<Exclude<H[T[K]], undefined>> | ReturnType<E>;
/**
 * Match a variant against some of its possible options and do some
 * processing based on the type of variant received. May return undefined
 * if the variant is not accounted for by the handler.
 * @param obj
 * @param handler
 * @param typeKey override the property to inspect. By default, 'type'.
 */
export declare function partialMatch<T extends WithProperty<K, string>, H extends Handler<VariantsOfUnion<T, K>>, K extends string = 'type'>(obj: T, handler: Partial<H>, typeKey?: K): ReturnType<Defined<H[T[K]]>> | undefined;
/**
 * Match a literal against some of its possible options and do some processing based
 * on the type of literal received. Works well with strEnum
 * @param literal
 * @param handler
 */
export declare function matchLiteral<T extends string, H extends UnionHandler<T>>(literal: T, handler: H): ReturnType<H[T]>;
/**
 * An object that has the same keys as a variant but has arbitrary values for the data.
 * a.k.a. a lookup table.
 */
export declare type Lookup<T, U = any> = {
    [P in keyof T]: U;
};
/**
 * Map a variant to some value based on the type of variant provided.
 * @param obj
 * @param handler
 * @param typeKey
 */
export declare function lookup<T extends WithProperty<K, string>, L extends Lookup<VariantsOfUnion<T, K>>, K extends string = 'type'>(obj: T, handler: L, typeKey?: K): ReturnType<L[T[K]]>;
/**
 * Map a variant to some value or undefined based on the type of variant
 * provided. If he handler does not account for your use case, undefined
 * will be returned. The type of undefined is the union of the various
 * values in the object.
 * @param obj
 * @param handler
 * @param typeKey
 */
export declare function partialLookup<T extends WithProperty<K, string>, L extends Lookup<VariantsOfUnion<T, K>>, K extends string = 'type'>(obj: T, handler: Partial<L>, typeKey?: K): ReturnType<L[T[K]]> | undefined;
export declare type AugmentVariant<T extends VariantModule, U> = {
    [P in keyof T]: ((...args: Parameters<T[P]>) => Identity<ReturnType<T[P]> & U>) & Outputs<T[P]['key'], T[P]['type']>;
};
export declare function cast<O extends WithProperty<K, string>, T extends O[K], K extends string = 'type'>(obj: O, _type: T, _typeKey?: K): ExtractOfUnion<O, T, K>;
export declare function narrow<O extends WithProperty<K, string>, T extends O[K], K extends string = 'type'>(obj: O, type: T, typeKey?: K): ExtractOfUnion<O, T, K> | undefined;
/**
 * Expand the functionality of a variant as a whole by tacking on properties
 * generated by a thunk.
 * @param variantDef
 * @param f
 */
export declare function augment<T extends VariantModule, F extends Func>(variantDef: T, f: F): AugmentVariant<T, ReturnType<F>>;
export declare type SumType<T extends VariantModule<K>, K extends string = 'type'> = VariantsOf<T, K>[keyof T];
export declare type KeyMap<T extends VariantModule<K>, K extends string = 'type'> = {
    [Label in keyof T]: T[Label] extends VariantCreator<infer TypeStr, Func, K> ? TypeStr : never;
};
export declare type KeysOf<T extends VariantModule<K>, K extends string = 'type'> = KeyMap<T, K>[keyof T];
export declare type TypeNames<T extends VariantModule<K>, K extends string = 'type'> = KeysOf<T, K> | undefined;
export declare type VariantOf<T extends VariantModule<K>, TType = undefined, K extends string = 'type'> = TType extends undefined ? SumType<T, K> : TType extends KeysOf<T, K> ? ExtractOfUnion<SumType<T, K>, TType, K> : SumType<T, K>;
export declare function keynum<T extends VariantModule>(variantDef: T): {
    [P in KeysOf<T>]: P;
};
export declare type Matrix<T extends VariantModule<K>, K extends string = 'type'> = {
    [P in KeysOf<T, K>]: ExtractOfUnion<SumType<T, K>, P, K>;
};
export declare type Flags<T extends VariantModule> = Partial<Matrix<T>>;
export declare function flags<T extends WithProperty<K, string>, K extends string = 'type'>(flags: T[]): {
    [P in T[K]]: ExtractOfUnion<T, P, K>;
};
//# sourceMappingURL=variant.d.ts.map